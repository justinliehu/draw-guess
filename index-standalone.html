<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ä½ ç”»æˆ‘çŒœ - çº¿ä¸Šç‰ˆ</title>
  <meta name="description" content="æ”¯æŒ Phantom/Solflare é’±åŒ…çš„å¤šäººä½ ç”»æˆ‘çŒœæ¸¸æˆ">
  <meta name="theme-color" content="#7c3aed">
  <link rel="manifest" href="manifest.json">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #0f0e17;
      --surface: #1a1925;
      --surface-hover: #252336;
      --primary: #7c3aed;
      --primary-hover: #8b5cf6;
      --accent: #22d3ee;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --success: #22c55e;
      --warning: #f59e0b;
      --radius: 12px;
      --shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    button {
      cursor: pointer;
      font: inherit;
      border: none;
      border-radius: var(--radius);
      padding: 0.75rem 1.25rem;
      background: var(--primary);
      color: white;
      transition: background 0.2s, transform 0.1s;
      font-size: 0.95rem;
    }

    button:hover {
      background: var(--primary-hover);
    }

    button:active {
      transform: scale(0.98);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    input {
      font: inherit;
      padding: 0.75rem 1rem;
      border: 2px solid var(--surface-hover);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      width: 100%;
      font-size: 0.95rem;
    }

    input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .page {
      min-height: 100vh;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .page-title {
      font-size: clamp(1.5rem, 5vw, 1.75rem);
      margin-bottom: 1.5rem;
      font-weight: 700;
      text-align: center;
    }

    .card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 1.25rem;
      box-shadow: var(--shadow);
      width: 100%;
      max-width: 420px;
    }

    .card-title {
      font-size: 1rem;
      margin-bottom: 1rem;
      color: var(--text-muted);
    }

    /* é’±åŒ…è¿æ¥å¼¹çª— */
    .wallet-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .wallet-modal-content {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 1.5rem;
      max-width: 400px;
      width: 100%;
      box-shadow: var(--shadow);
    }

    .wallet-option {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: var(--surface-hover);
      border-radius: var(--radius);
      cursor: pointer;
      transition: background 0.2s;
      margin-bottom: 0.75rem;
      border: 2px solid transparent;
    }

    .wallet-option:hover {
      background: var(--bg);
      border-color: var(--primary);
    }

    .wallet-option img {
      width: 32px;
      height: 32px;
    }

    .wallet-option span {
      flex: 1;
      font-weight: 600;
    }

    /* æ¸¸æˆè¿›è¡Œé¡µ */
    .game-play {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 0.5rem;
    }

    .game-play-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      background: var(--surface);
      border-radius: var(--radius);
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .game-play-body {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
    }

    @media (min-width: 900px) {
      .game-play-body {
        grid-template-columns: 1fr 320px;
      }
    }

    .canvas-wrap {
      background: var(--surface);
      padding: 0.75rem;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #draw-canvas {
      max-width: 100%;
      height: auto;
      touch-action: none;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      justify-content: center;
    }

    .toolbar button {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
    }

    .toolbar button.active {
      background: var(--accent);
      color: var(--bg);
    }

    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      padding: 0;
      border: 2px solid var(--surface-hover);
      border-radius: var(--radius);
      cursor: pointer;
    }

    .toolbar input[type="range"] {
      width: 100px;
    }

    .game-aside {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
    }

    .game-aside .card {
      max-width: none;
    }

    .chat-messages {
      max-height: 150px;
      overflow-y: auto;
      padding: 0.5rem 0;
      font-size: 0.9rem;
    }

    .hidden {
      display: none !important;
    }

    /* çŒœè¯æ–¹æ˜¾ç¤ºç”»å¸ƒï¼Œä½†ä¸æ˜¾ç¤ºè¯è¯­ï¼ˆåªæ˜¾ç¤ºç±»åˆ«ï¼‰ */
    #page-game[data-role="guesser"] #draw-section-guesser {
      display: none !important;
    }

    /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
    @media (max-width: 600px) {
      .page {
        padding: 0.75rem;
      }

      .card {
        padding: 1rem;
      }

      .page-title {
        font-size: 1.5rem;
      }

      button {
        padding: 0.65rem 1rem;
        font-size: 0.9rem;
      }

      .game-play-header {
        font-size: 0.85rem;
      }

      .toolbar {
        gap: 0.4rem;
      }

      .toolbar button {
        padding: 0.4rem 0.75rem;
        font-size: 0.8rem;
      }
    }

    /* é’±åŒ…è¿æ¥çŠ¶æ€æ˜¾ç¤º */
    .wallet-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--surface-hover);
      border-radius: var(--radius);
      font-size: 0.85rem;
      margin-bottom: 1rem;
    }

    .wallet-status.connected {
      background: rgba(34, 197, 94, 0.2);
      color: var(--success);
    }

    .game-rules-btn {
      width: 1.75rem;
      height: 1.75rem;
      padding: 0;
      border: none;
      border-radius: 50%;
      background: var(--surface-hover);
      color: var(--text-muted);
      font-size: 1rem;
      cursor: pointer;
      flex-shrink: 0;
    }
    .game-rules-btn:hover {
      background: var(--accent);
      color: white;
    }
  </style>
</head>
<body>
  <!-- é’±åŒ…è¿æ¥å¼¹çª— -->
  <div id="wallet-modal" class="wallet-modal hidden">
    <div class="wallet-modal-content">
      <h2 style="margin-bottom: 0.5rem; text-align: center" id="wallet-modal-title" data-i18n="noWallet">æœªæ£€æµ‹åˆ°é’±åŒ…</h2>
      <p style="text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1rem" id="wallet-modal-desc" data-i18n="installWallet">è¯·å®‰è£…ä»¥ä¸‹ä»»ä¸€æ‰©å±•ååˆ·æ–°é¡µé¢ï¼Œå†ç‚¹å‡»ã€Œè¿æ¥é’±åŒ…ã€å°†è‡ªåŠ¨å¼¹çª—è¿æ¥</p>
      <div class="wallet-option" onclick="connectWallet('phantom')">
        <span>ğŸ¦„ Phantom</span>
      </div>
      <div class="wallet-option" onclick="connectWallet('solflare')">
        <span>ğŸ”¥ Solflare</span>
      </div>
      <button onclick="closeWalletModal()" style="width: 100%; margin-top: 1rem; background: var(--surface-hover)" data-i18n="cancel">å–æ¶ˆ</button>
    </div>
  </div>

  <!-- è¯­è¨€åˆ‡æ¢ -->
  <div style="position: fixed; top: 0.75rem; right: 0.75rem; z-index: 100">
    <button id="btn-lang" type="button" style="padding: 0.4rem 0.75rem; font-size: 0.85rem; background: var(--surface-hover)">EN</button>
  </div>

  <!-- æ¸¸æˆå¤§å…ï¼ˆå…¥å£é¡µï¼‰ -->
  <div id="page-lobby" class="page">
    <div style="max-width: 480px; width: 100%">
      <h1 class="page-title" data-i18n="title">ä½ ç”»æˆ‘çŒœ Â· çº¿ä¸Šç‰ˆ</h1>
      <!-- å¤§å…ä¸Šæ–¹ï¼šè¿æ¥é’±åŒ… / åŒ¿åç™»å½• æˆ– å·²è¿æ¥çŠ¶æ€ -->
      <div id="lobby-account" class="card" style="margin-bottom: 1rem; padding: 1rem">
        <div id="lobby-account-connected" style="display: none">
          <span data-i18n="loggedInAs">å½“å‰è´¦å·</span>: <span id="lobby-account-name"></span>
          <button type="button" onclick="lobbyLogout()" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.85rem; background: var(--surface-hover)" data-i18n="logout">ç™»å‡º</button>
        </div>
        <div id="lobby-account-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap">
          <button type="button" onclick="lobbyConnectWallet()" style="flex: 1; min-width: 120px" data-i18n="connectWallet">è¿æ¥é’±åŒ…</button>
          <button type="button" onclick="lobbyAnonymous()" style="flex: 1; min-width: 120px; background: var(--surface-hover)" data-i18n="anonymous">åŒ¿åç™»å½•</button>
        </div>
      </div>
      <div id="lobby-sync-tip" class="card" style="margin-bottom: 1rem; background: var(--surface-hover); padding: 1rem; font-size: 0.9rem; display: none"></div>
      <p style="color: var(--text-muted); margin-bottom: 1.5rem; text-align: center"><span data-i18n="online">åœ¨çº¿äººæ•°</span>: <span id="online-count">0</span></p>
      <div style="display: flex; flex-direction: column; gap: 1rem">
        <div class="card" style="display: flex; align-items: center; justify-content: space-between; flex-direction: row; cursor: pointer" onclick="enterGame('draw-guess')">
          <span style="font-size: 2rem">ğŸ¨</span>
          <span style="flex: 1; margin-left: 1rem; font-weight: 600" data-i18n="drawGuess">ä½ ç”»æˆ‘çŒœ</span>
          <button type="button" class="game-rules-btn" onclick="event.stopPropagation(); showGameRules('draw-guess')" title="è§„åˆ™" aria-label="è§„åˆ™">â“˜</button>
          <button onclick="event.stopPropagation(); enterGame('draw-guess')" data-i18n="enterGame">è¿›å…¥æ¸¸æˆ</button>
        </div>
        <div class="card" style="display: flex; align-items: center; justify-content: space-between; flex-direction: row; opacity: 0.6; cursor: not-allowed">
          <span style="font-size: 2rem">ğŸ•µ</span>
          <span style="flex: 1; margin-left: 1rem; font-weight: 600" data-i18n="gameUndercover">è°æ˜¯å§åº•</span>
          <button type="button" class="game-rules-btn" onclick="event.stopPropagation(); showGameRules('undercover')" style="opacity: 0.8" title="è§„åˆ™" aria-label="è§„åˆ™">â“˜</button>
          <span style="color: var(--text-muted); font-size: 0.9rem" data-i18n="comingSoon">å³å°†æ¨å‡º</span>
        </div>
        <div class="card" style="display: flex; align-items: center; justify-content: space-between; flex-direction: row; opacity: 0.6; cursor: not-allowed">
          <span style="font-size: 2rem">âš¡</span>
          <span style="flex: 1; margin-left: 1rem; font-weight: 600" data-i18n="gameQuiz">å¿«é€Ÿé—®ç­”</span>
          <button type="button" class="game-rules-btn" onclick="event.stopPropagation(); showGameRules('quiz')" style="opacity: 0.8" title="è§„åˆ™" aria-label="è§„åˆ™">â“˜</button>
          <span style="color: var(--text-muted); font-size: 0.9rem" data-i18n="comingSoon">å³å°†æ¨å‡º</span>
        </div>
      </div>
      <div class="card" style="max-width: 480px; margin-top: 1rem">
        <p class="card-title" data-i18n="existingRooms">å·²æœ‰æˆ¿é—´ Â· å¿«é€Ÿè¿›å…¥</p>
        <div id="existing-rooms-list">
          <p style="color: var(--text-muted); font-size: 0.9rem; margin: 0" data-i18n="noRooms">æš‚æ— å…¶ä»–æˆ¿é—´ï¼Œåˆ›å»ºæˆ–è¾“å…¥æˆ¿é—´å·åŠ å…¥</p>
        </div>
      </div>
      <button onclick="joinRoom()" style="width: 100%; margin-top: 1rem; background: var(--surface-hover)" data-i18n="joinByCode">è¾“å…¥æˆ¿é—´å·åŠ å…¥</button>
    </div>
  </div>

  <!-- æ¸¸æˆè§„åˆ™å¼¹çª— -->
  <div id="game-rules-modal" class="wallet-modal hidden" onclick="if(event.target===this) closeGameRulesModal()">
    <div class="wallet-modal-content" style="max-width: 420px; max-height: 85vh; overflow-y: auto" onclick="event.stopPropagation()">
      <h2 id="game-rules-title" style="margin-bottom: 0.75rem; text-align: center"></h2>
      <div id="game-rules-body" style="color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; white-space: pre-line"></div>
      <button onclick="closeGameRulesModal()" style="width: 100%; margin-top: 1rem; background: var(--surface-hover)" data-i18n="cancel">å–æ¶ˆ</button>
    </div>
  </div>

  <!-- æˆ¿é—´é¡µ -->
  <div id="page-room" class="page hidden" style="justify-content: flex-start; padding: 1rem">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 600px; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem">
      <h1 class="page-title" style="margin-bottom: 0; font-size: clamp(1.25rem, 4vw, 1.5rem)"><span data-i18n="room">æˆ¿é—´</span>ï¼š<span id="room-id">1234</span></h1>
      <button onclick="goToLobby()" style="background: var(--surface-hover); font-size: 0.9rem" data-i18n="leaveRoom">é€€å‡ºæˆ¿é—´</button>
    </div>
    <div class="card" style="max-width: 600px; width: 100%; margin-bottom: 1rem">
      <p class="card-title"><span data-i18n="playerList">ç©å®¶åˆ—è¡¨</span> (<span id="player-count">0</span>)</p>
      <ul id="player-list" style="list-style: none"></ul>
      <p id="countdown-text" style="margin-top: 1rem; color: var(--accent); font-weight: 600; display: none; text-align: center"></p>
      <div id="confirm-area" style="margin-top: 0.75rem; display: none; text-align: center">
        <button id="btn-start" type="button" onclick="confirmStart()" style="min-width: 160px" data-i18n="start">å¼€å§‹</button>
        <span id="confirm-done" style="display: none; color: var(--success)" data-i18n="confirmed">å·²ç¡®è®¤</span>
      </div>
    </div>
    <div class="card" style="max-width: 600px; width: 100%; flex: 1; display: flex; flex-direction: column; min-height: 200px">
      <p class="card-title" data-i18n="chat">èŠå¤©</p>
      <div id="chat-messages" style="flex: 1; min-height: 100px; max-height: 200px; overflow-y: auto; margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg); border-radius: var(--radius)">
        <span id="chat-no-msg" style="color: var(--text-muted)" data-i18n="noMsg">æš‚æ— æ¶ˆæ¯</span>
      </div>
      <div style="display: flex; gap: 0.5rem">
        <input id="chat-input" type="text" data-i18n-placeholder="inputMsg" placeholder="è¾“å…¥æ¶ˆæ¯..." onkeydown="if(event.key==='Enter') sendChat()">
        <button onclick="sendChat()" style="white-space: nowrap" data-i18n="send">å‘é€</button>
      </div>
    </div>
    <button id="btn-ready" onclick="toggleReady()" style="margin-top: 1rem; min-width: 160px" data-i18n="ready">å‡†å¤‡</button>
  </div>

  <!-- æ¸¸æˆè¿›è¡Œé¡µ -->
  <div id="page-game" class="game-play hidden" data-role="guesser">
    <header class="game-play-header">
      <span><span id="game-header-room" data-i18n="roomColon">æˆ¿é—´</span>ï¼š<span id="game-room-id">1234</span></span>
      <span id="game-header-round-line"><span id="game-header-round" data-i18n="roundNum">ç¬¬</span> <span id="current-round">2</span> / <span id="max-rounds">8</span><span id="game-header-round-suffix"></span></span>
    </header>
    <div class="game-play-body">
      <section class="game-section draw-section" id="draw-section-painter">
        <div class="canvas-wrap">
          <canvas id="draw-canvas" width="800" height="600" style="background: #1e1e2e; border-radius: var(--radius); touch-action: none; cursor: crosshair; width: 100%; max-width: 800px"></canvas>
        </div>
        <div class="toolbar" id="draw-toolbar">
          <button id="tool-brush" class="active" onclick="setTool('brush')" data-i18n="brush">ç”»ç¬”</button>
          <button id="tool-eraser" onclick="setTool('eraser')" data-i18n="eraser">æ©¡çš®</button>
          <input type="color" id="brush-color" value="#ffffff">
          <input type="range" id="brush-size" min="2" max="20" value="4">
          <button onclick="clearCanvas()" data-i18n="clear">æ¸…ç©º</button>
        </div>
      </section>
      <section class="game-section draw-section" id="draw-section-guesser" style="display: none; align-items: center; justify-content: center; min-height: 280px; background: var(--surface); border-radius: var(--radius); padding: 2rem;">
        <p style="color: var(--text-muted); font-size: 1.1rem; text-align: center;" data-i18n="painterDrawing">ç”»å®¶æ­£åœ¨ä½œç”»ï¼Œè¯·æ ¹æ®ä¸‹æ–¹ç±»åˆ«æç¤ºçŒœè¯</p>
      </section>
      <aside class="game-aside">
        <div class="card game-state-card">
          <p class="card-title" data-i18n="gameState">æ¸¸æˆçŠ¶æ€</p>
          <p><span data-i18n="painter">ç”»å®¶</span>ï¼š<span id="painter-name">-</span></p>
          <p><span data-i18n="time">æ—¶é—´</span>ï¼š<span id="round-time">45</span> <span data-i18n="sec">ç§’</span></p>
          <p id="round-display-line"><span data-i18n="rounds">è½®æ•°</span>ï¼š<span id="round-info">2</span> / <span id="max-rounds-info">8</span><span id="round-suffix"></span></p>
        </div>
        <div class="card word-hint-card">
          <p class="card-title" data-i18n="currentWord">å½“å‰è¯è¯­</p>
          <p id="word-display" style="font-size: 1.5rem; letter-spacing: 4px; font-weight: 700; text-align: center">ç±»åˆ«ï¼šåŠ¨ç‰©</p>
        </div>
        <div class="card score-card">
          <p class="card-title" data-i18n="scoreboard">ç§¯åˆ†æ¦œ</p>
          <ul id="score-list" style="list-style: none"></ul>
        </div>
        <div class="card chat-card">
          <p class="card-title" data-i18n="guessChat">çŒœè¯ / èŠå¤©</p>
          <div id="game-chat-messages" class="chat-messages"></div>
          <div id="guess-input-area" style="display: flex; gap: 0.5rem; margin-top: 0.5rem">
            <input id="guess-input" type="text" data-i18n-placeholder="inputAnswer" placeholder="è¾“å…¥ç­”æ¡ˆ..." onkeydown="if(event.key==='Enter') handleGuess()">
            <button onclick="handleGuess()" style="white-space: nowrap" data-i18n="send">å‘é€</button>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <!-- å›åˆç»“æŸé¡µ -->
  <div id="page-round-end" class="page hidden">
    <div class="card" style="max-width: 400px; text-align: center">
      <h2 style="margin-bottom: 1rem; color: var(--accent)" data-i18n="roundEnd">å›åˆç»“æŸ</h2>
      <p class="card-title" data-i18n="correctAnswer">æ­£ç¡®ç­”æ¡ˆ</p>
      <p id="round-answer" style="font-size: 2rem; font-weight: 700; margin-bottom: 1.5rem">CAT</p>
      <div id="round-scores" style="text-align: left; margin-bottom: 1rem"></div>
      <p style="color: var(--text-muted); font-size: 0.9rem" data-i18n="nextRoundIn">ç§’åè¿›å…¥ä¸‹ä¸€è½®...</p>
    </div>
  </div>

  <!-- æ¸¸æˆç»“æŸé¡µ -->
  <div id="page-game-end" class="page hidden">
    <div class="card" style="max-width: 420px; text-align: center">
      <h1 style="margin-bottom: 0.5rem; font-size: 2rem">ğŸ† <span data-i18n="gameOver">æ¸¸æˆç»“æŸ</span></h1>
      <p class="card-title" style="margin-bottom: 1.5rem" data-i18n="finalRank">æœ€ç»ˆæ’å</p>
      <ul id="final-ranking" style="list-style: none; margin-bottom: 1.5rem"></ul>
      <div style="display: flex; gap: 0.75rem; flex-direction: column">
        <button onclick="playAgain()" style="width: 100%" data-i18n="playAgain">å†æ¥ä¸€å±€</button>
        <button onclick="goToLobby()" style="width: 100%; background: var(--surface-hover)" data-i18n="backLobby">å›åˆ°å¤§å…</button>
      </div>
    </div>
  </div>

  <script>
    // ========== è¯­è¨€ ==========
    var lang = localStorage.getItem('game_lang') || 'zh'
    var i18n = {
      zh: {
        title: 'ä½ ç”»æˆ‘çŒœ Â· çº¿ä¸Šç‰ˆ',
        loginType: 'é€‰æ‹©ç™»å½•æ–¹å¼',
        connectWallet: 'è¿æ¥é’±åŒ…',
        anonymous: 'åŒ¿åç™»å½•',
        nickname: 'è¾“å…¥æ˜µç§°',
        nicknameOnce: 'ä¸ºè¯¥é’±åŒ…è®¾ç½®æ˜µç§°ï¼ˆä»…æ­¤ä¸€æ¬¡ï¼‰',
        enter: 'è¿›å…¥æ¸¸æˆ',
        lobby: 'æ¸¸æˆå¤§å…',
        online: 'åœ¨çº¿äººæ•°',
        drawGuess: 'ä½ ç”»æˆ‘çŒœ',
        enterGame: 'è¿›å…¥æ¸¸æˆ',
        existingRooms: 'å·²æœ‰æˆ¿é—´ Â· å¿«é€Ÿè¿›å…¥',
        joinByCode: 'è¾“å…¥æˆ¿é—´å·åŠ å…¥',
        room: 'æˆ¿é—´',
        leaveRoom: 'é€€å‡ºæˆ¿é—´',
        playerList: 'ç©å®¶åˆ—è¡¨',
        start: 'å¼€å§‹',
        confirmed: 'å·²ç¡®è®¤',
        chat: 'èŠå¤©',
        inputMsg: 'è¾“å…¥æ¶ˆæ¯...',
        send: 'å‘é€',
        ready: 'å‡†å¤‡',
        gameState: 'æ¸¸æˆçŠ¶æ€',
        painter: 'ç”»å®¶',
        time: 'æ—¶é—´',
        sec: 'ç§’',
        rounds: 'è½®æ•°',
        round: ' è½®',
        currentWord: 'å½“å‰è¯è¯­',
        category: 'ç±»åˆ«',
        scoreboard: 'ç§¯åˆ†æ¦œ',
        guessChat: 'çŒœè¯ / èŠå¤©',
        inputAnswer: 'è¾“å…¥ç­”æ¡ˆ...',
        painterDrawing: 'ç”»å®¶æ­£åœ¨ä½œç”»ï¼Œè¯·æ ¹æ®ä¸‹æ–¹ç±»åˆ«æç¤ºçŒœè¯',
        roundEnd: 'å›åˆç»“æŸ',
        correctAnswer: 'æ­£ç¡®ç­”æ¡ˆ',
        nextRoundIn: 'ç§’åè¿›å…¥ä¸‹ä¸€è½®...',
        gameOver: 'æ¸¸æˆç»“æŸ',
        finalRank: 'æœ€ç»ˆæ’å',
        playAgain: 'å†æ¥ä¸€å±€',
        backLobby: 'å›åˆ°å¤§å…',
        logout: 'ç™»å‡º',
        logIn: 'ç™»å½•',
        loggedInAs: 'å½“å‰è´¦å·',
        notLoggedIn: 'æœªç™»å½•',
        noRooms: 'æš‚æ— å…¶ä»–æˆ¿é—´ï¼Œåˆ›å»ºæˆ–è¾“å…¥æˆ¿é—´å·åŠ å…¥',
        comingSoon: 'å³å°†æ¨å‡º',
        youGotIt: 'ä½ çŒœå¯¹äº†ï¼',
        someoneGotIt: 'çŒœå¯¹äº†',
        xx: 'xx',
        noWallet: 'æœªæ£€æµ‹åˆ°é’±åŒ…',
        installWallet: 'è¯·å®‰è£…ä»¥ä¸‹ä»»ä¸€æ‰©å±•ååˆ·æ–°é¡µé¢ï¼Œå†ç‚¹å‡»ã€Œè¿æ¥é’±åŒ…ã€å°†è‡ªåŠ¨å¼¹çª—è¿æ¥',
        cancel: 'å–æ¶ˆ',
        brush: 'ç”»ç¬”',
        eraser: 'æ©¡çš®',
        clear: 'æ¸…ç©º',
        roomColon: 'æˆ¿é—´',
        roundNum: 'ç¬¬ ',
        noPlayers: 'æš‚æ— ç©å®¶',
        notConfirmed: 'æœªç¡®è®¤',
        countdownTip: 'å‰©ä½™ {{n}} ç§’ï¼ŒæœªæŒ‰ã€Œå¼€å§‹ã€å°†è¢«ç§»å‡ºæˆ¿é—´',
        cancelReady: 'å–æ¶ˆå‡†å¤‡',
        noMsg: 'æš‚æ— æ¶ˆæ¯',
        roomPeople: 'æˆ¿é—´ {{id}} Â· {{n}} äºº',
        quickEnter: 'å¿«é€Ÿè¿›å…¥',
        promptRoomCode: 'è¯·è¾“å…¥æˆ¿é—´å·ï¼ˆ4ä½æ•°å­—ï¼‰',
        invalidRoomCode: 'æˆ¿é—´å·å¿…é¡»æ˜¯4ä½æ•°å­—',
        gameStartedNoJoin: 'æ¸¸æˆå·²å¼€å§‹ï¼Œæ— æ³•åŠ å…¥è¯¥æˆ¿é—´',
        timeoutKicked: 'è¶…æ—¶æœªæŒ‰ã€Œå¼€å§‹ã€ï¼Œå·²ç§»å‡ºæˆ¿é—´',
        rank: 'ç¬¬{{n}}å',
        notReady: 'æœªå‡†å¤‡',
        nicknameRequired: 'è¯·è¾“å…¥æ˜µç§°',
        nicknameWalletOnce: 'è¯·ä¸ºè¯¥é’±åŒ…è¾“å…¥æ˜µç§°ï¼ˆä»…éœ€è®¾ç½®ä¸€æ¬¡ï¼‰',
        connectFailed: 'è¿æ¥å¤±è´¥',
        noPhantom: 'æœªæ£€æµ‹åˆ° Phantomï¼Œè¯·å…ˆå®‰è£…æ‰©å±•\nhttps://phantom.app',
        noSolflare: 'æœªæ£€æµ‹åˆ° Solflareï¼Œè¯·å…ˆå®‰è£…æ‰©å±•\nhttps://solflare.com',
        gameUndercover: 'è°æ˜¯å§åº•',
        gameQuiz: 'å¿«é€Ÿé—®ç­”',
        drawGuessRules: 'ã€ä½ ç”»æˆ‘çŒœã€‘\nÂ· æ¯å±€è½®æµä¸€äººå½“ç”»å®¶ï¼Œå…¶ä»–äººçŒœè¯ã€‚\nÂ· ç”»å®¶æ ¹æ®ç³»ç»Ÿç»™å‡ºçš„è¯è¯­åœ¨ç”»å¸ƒä¸Šä½œç”»ï¼ŒçŒœè¯æ–¹æ ¹æ®ç±»åˆ«æç¤ºè¾“å…¥ç­”æ¡ˆã€‚\nÂ· å…ˆçŒœå¯¹è€…å¾—åˆ†æ›´é«˜ï¼›ç”»å®¶æ ¹æ®çŒœå¯¹äººæ•°å¾—åˆ†ã€‚\nÂ· å›åˆæ—¶é—´ç»“æŸæˆ–å…¨å‘˜çŒœå¯¹åè¿›å…¥ä¸‹ä¸€è½®ï¼Œè½®æ•° = äººæ•°Ã—3ã€‚',
        undercoverRules: 'ã€è°æ˜¯å§åº•ã€‘\nå³å°†æ¨å‡ºï¼Œæ•¬è¯·æœŸå¾…ã€‚',
        quizRules: 'ã€å¿«é€Ÿé—®ç­”ã€‘\nå³å°†æ¨å‡ºï¼Œæ•¬è¯·æœŸå¾…ã€‚'
      },
      en: {
        title: 'Draw & Guess Â· Online',
        loginType: 'Login',
        connectWallet: 'Connect Wallet',
        anonymous: 'Anonymous',
        nickname: 'Nickname',
        nicknameOnce: 'Set nickname for this wallet (once only)',
        enter: 'Enter',
        lobby: 'Lobby',
        online: 'Online',
        drawGuess: 'Draw & Guess',
        enterGame: 'Enter Game',
        existingRooms: 'Rooms Â· Quick Join',
        joinByCode: 'Join by room code',
        room: 'Room',
        leaveRoom: 'Leave',
        playerList: 'Players',
        start: 'Start',
        confirmed: 'Confirmed',
        chat: 'Chat',
        inputMsg: 'Type a message...',
        send: 'Send',
        ready: 'Ready',
        gameState: 'Game',
        painter: 'Painter',
        time: 'Time',
        sec: 's',
        rounds: 'Rounds',
        round: '',
        currentWord: 'Word',
        category: 'Category',
        scoreboard: 'Score',
        guessChat: 'Guess / Chat',
        inputAnswer: 'Your guess...',
        painterDrawing: 'The painter is drawing. Guess from the category below.',
        roundEnd: 'Round Over',
        correctAnswer: 'Answer',
        nextRoundIn: 'Next round in a few seconds...',
        gameOver: 'Game Over',
        finalRank: 'Final Ranking',
        playAgain: 'Play Again',
        backLobby: 'Back to Lobby',
        logout: 'Log out',
        logIn: 'Log in',
        loggedInAs: 'Logged in as',
        notLoggedIn: 'Not logged in',
        noRooms: 'No rooms yet. Create or enter a code.',
        comingSoon: 'Coming soon',
        youGotIt: 'You got it!',
        someoneGotIt: 'got it',
        xx: 'xx',
        noWallet: 'No wallet detected',
        installWallet: 'Install Phantom or Solflare, refresh the page, then click Connect Wallet.',
        cancel: 'Cancel',
        brush: 'Brush',
        eraser: 'Eraser',
        clear: 'Clear',
        roomColon: 'Room',
        roundNum: 'Round ',
        noPlayers: 'No players yet',
        notConfirmed: 'Not confirmed',
        countdownTip: '{{n}}s left. Press Start or you will be removed.',
        cancelReady: 'Cancel ready',
        noMsg: 'No messages',
        roomPeople: 'Room {{id}} Â· {{n}}',
        quickEnter: 'Join',
        promptRoomCode: 'Enter room code (4 digits)',
        invalidRoomCode: 'Room code must be 4 digits',
        gameStartedNoJoin: 'Game has started. Cannot join.',
        timeoutKicked: 'Timeout. You were removed from the room.',
        rank: '{{n}}',
        notReady: 'Not ready',
        nicknameRequired: 'Please enter nickname',
        nicknameWalletOnce: 'Please set a nickname for this wallet (once only)',
        connectFailed: 'Connection failed',
        noPhantom: 'Phantom not found. Install: https://phantom.app',
        noSolflare: 'Solflare not found. Install: https://solflare.com',
        gameUndercover: 'Undercover',
        gameQuiz: 'Quick Quiz',
        drawGuessRules: 'ã€Draw & Guessã€‘\nÂ· Each round one player is the painter, others guess.\nÂ· The painter draws the word given by the game; guessers type answers based on the category.\nÂ· Earlier correct guesses score more; the painter scores by how many guessed correctly.\nÂ· Round ends when time runs out or everyone guessed. Total rounds = players Ã— 3.',
        undercoverRules: 'ã€Undercoverã€‘\nComing soon.',
        quizRules: 'ã€Quick Quizã€‘\nComing soon.'
      }
    }
    function t(k, vars) {
      var s = (i18n[lang] && i18n[lang][k]) || i18n.zh[k] || k
      if (vars && typeof s === 'string') {
        Object.keys(vars).forEach(function (key) { s = s.replace(new RegExp('\\{\\{' + key + '\\}\\}', 'g'), vars[key]) })
      }
      return s
    }
    function getCategoryLabel() {
      return (lang === 'en' && currentWordObj && currentWordObj.cat_en) ? currentWordObj.cat_en : wordCategory
    }
    function updateRoundSuffix() {
      var suffix = lang === 'en' ? '' : ' \u8f6e'
      var el = document.getElementById('round-suffix')
      if (el) el.textContent = suffix
      var headerEl = document.getElementById('game-header-round-suffix')
      if (headerEl) headerEl.textContent = suffix
    }

    function getCategoryDisplayForGuesser() {
      if (currentWordObj && currentWordObj.cat_zh && currentWordObj.cat_en) {
        return 'ç±»åˆ«ï¼š' + currentWordObj.cat_zh + ' / Category: ' + currentWordObj.cat_en
      }
      return t('category') + 'ï¼š' + getCategoryLabel()
    }
    function setLang(l) {
      lang = l
      localStorage.setItem('game_lang', l)
      applyI18n()
    }
    function toggleLang() {
      setLang(lang === 'zh' ? 'en' : 'zh')
    }
    function applyI18n() {
      var key
      document.querySelectorAll('[data-i18n]').forEach(function (el) {
        key = el.getAttribute('data-i18n')
        if (key) el.textContent = t(key)
      })
      document.querySelectorAll('[data-i18n-placeholder]').forEach(function (el) {
        key = el.getAttribute('data-i18n-placeholder')
        if (key) el.placeholder = t(key)
      })
      var langBtn = document.getElementById('btn-lang')
      if (langBtn) {
        langBtn.textContent = lang === 'zh' ? 'EN' : 'ä¸­æ–‡'
        langBtn.onclick = toggleLang
      }
      if (walletAddress) {
        var ws = document.getElementById('wallet-status')
        if (ws && !ws.classList.contains('hidden')) ws.innerHTML = 'âœ… ' + (lang === 'en' ? 'Connected: ' : 'å·²è¿æ¥: ') + walletAddress.slice(0, 4) + '...' + walletAddress.slice(-4) + ' <button type="button" onclick="logoutWallet()" style="margin-left:0.5rem;padding:0.2rem 0.5rem;font-size:0.8rem;background:var(--surface-hover)">' + t('logout') + '</button>'
      }
      if (typeof updateLobbySyncTip === 'function') updateLobbySyncTip()
      if (typeof updateRoundSuffix === 'function') updateRoundSuffix()
      document.title = lang === 'en' ? 'Draw & Guess Â· Online' : 'ä½ ç”»æˆ‘çŒœ Â· çº¿ä¸Šç‰ˆ'
    }

    // ========== çŠ¶æ€ç®¡ç† ==========
    let currentPage = 'login'
    let loginType = 'anonymous'
    let playerName = ''
    let playerId = ''
    let walletAddress = ''
    let walletProvider = null
    let roomId = ''
    let isReady = false
    let isPainter = false
    let roundTime = 45
    let currentRound = 2
    let maxRounds = 8
    let painterWord = 'CAT'
    let currentWordObj = null
    let wordHint = 'C _ T'
    let tool = 'brush'
    let brushColor = '#ffffff'
    let brushSize = 4
    let drawing = false
    let lastX = 0
    let lastY = 0
    let roomPlayers = []
    let roundTimer = null
    let roomPollTimer = null
    let gamePollTimer = null
    let canvasResizeHandler = null
    let gameWordSeed = '' // æœ¬å±€è¯è¯­ä¹±åºç§å­ï¼Œæ¯å±€ä¸åŒ

    // é€šè¿‡åŒä¸€æœåŠ¡å™¨æ‰“å¼€æ—¶ç”¨ API åŒæ­¥ï¼Œæ‰‹æœºå’Œç”µè„‘å¯åŒæˆ¿é—´ï¼›file:// ä»ç”¨ localStorage
    const useRoomApi = typeof location !== 'undefined' && location.protocol !== 'file:' && location.host
    const apiBase = useRoomApi ? (location.origin + '/api') : ''

    function getRoomPlayers(roomId) {
      const key = `room_${roomId}_players`
      const data = localStorage.getItem(key)
      return data ? JSON.parse(data) : []
    }

    function saveRoomPlayers(roomId, players) {
      const key = `room_${roomId}_players`
      localStorage.setItem(key, JSON.stringify(players))
      window.dispatchEvent(new StorageEvent('storage', { key, newValue: JSON.stringify(players) }))
    }

    async function getRoomPlayersAsync(roomId) {
      if (apiBase) {
        try {
          const r = await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/players')
          if (r.ok) return await r.json()
        } catch (e) {}
      }
      return getRoomPlayers(roomId)
    }

    async function saveRoomPlayersAsync(roomId, players) {
      if (apiBase) {
        try {
          var r = await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/players', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(players)
          })
          return r.ok
        } catch (e) { return false }
      }
      saveRoomPlayers(roomId, players)
      return true
    }

    async function getRoomStateAsync(roomId) {
      if (apiBase) {
        try {
          const r = await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/state')
          if (r.ok) return await r.json()
        } catch (e) {}
      }
      return { status: 'waiting' }
    }

    async function setRoomStateAsync(roomId, state) {
      if (apiBase) {
        try {
          await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/state', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(state)
          })
        } catch (e) {}
      }
    }

    async function confirmStartAsync(roomId, playerId) {
      if (apiBase) {
        try {
          await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/confirm', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ playerId: playerId })
          })
        } catch (e) {}
      }
    }

    async function postGuessAsync(roomId, body) {
      if (apiBase) {
        try {
          const r = await fetch(apiBase + '/rooms/' + encodeURIComponent(roomId) + '/guess', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          })
          if (r.ok) return await r.json()
        } catch (e) {}
      }
      return null
    }

    async function addPlayerToRoom(roomId, player) {
      if (apiBase) {
        var state = await getRoomStateAsync(roomId)
        if (state && state.status === 'playing') return null
      }
      const players = await getRoomPlayersAsync(roomId)
      if (!players.find(p => p.id === player.id)) {
        if (apiBase) {
          var state2 = await getRoomStateAsync(roomId)
          if (state2 && state2.status === 'playing') return null
        }
        players.push(player)
        var ok = await saveRoomPlayersAsync(roomId, players)
        if (apiBase && !ok) return null
      }
      return players
    }

    async function updatePlayerReady(roomId, playerId, ready) {
      const players = await getRoomPlayersAsync(roomId)
      const player = players.find(p => p.id === playerId)
      if (player) {
        player.ready = ready
        await saveRoomPlayersAsync(roomId, players)
      }
      return players
    }

    async function removePlayerFromRoom(roomId, playerId) {
      const players = await getRoomPlayersAsync(roomId)
      const filtered = players.filter(p => p.id !== playerId)
      await saveRoomPlayersAsync(roomId, filtered)
      return filtered
    }

    window.addEventListener('storage', (e) => {
      if (e.key && e.key.startsWith('room_') && e.key.endsWith('_players')) {
        const roomIdFromKey = e.key.replace('room_', '').replace('_players', '')
        if (roomIdFromKey === roomId && currentPage === 'room') {
          getRoomPlayersAsync(roomId).then((p) => { roomPlayers = p; updateRoomPage() })
        }
        if (currentPage === 'lobby') {
          updateExistingRoomsList()
          updateOnlineCount()
        }
      }
    })

    // ========== é’±åŒ…è¿æ¥ ==========
    function selectLoginType(type) {
      loginType = type
      const btnWallet = document.getElementById('btn-wallet')
      const btnAnonymous = document.getElementById('btn-anonymous')
      const walletStatus = document.getElementById('wallet-status')
      
      if (type === 'wallet') {
        btnWallet.style.background = 'var(--primary)'
        btnAnonymous.style.background = 'var(--surface-hover)'
        if (!walletAddress) {
          // è‡ªåŠ¨å”¤èµ·å·²å®‰è£…çš„é’±åŒ…æ‰©å±•å¼¹çª—
          autoConnectWallet()
        }
      } else {
        btnAnonymous.style.background = 'var(--primary)'
        btnWallet.style.background = 'var(--surface-hover)'
        walletStatus.classList.add('hidden')
      }
    }

    /** è‡ªåŠ¨æ£€æµ‹å¹¶å”¤èµ· Phantom æˆ– Solflare æ‰©å±•å¼¹çª—è¿›è¡Œè¿æ¥ */
    async function autoConnectWallet() {
      let provider = null
      let walletType = ''
      // ä¼˜å…ˆ Phantomï¼Œå…¶æ¬¡ Solflare
      if (typeof window.solana !== 'undefined' && window.solana.isPhantom) {
        provider = window.solana
        walletType = 'phantom'
      } else if (typeof window.solflare !== 'undefined') {
        provider = window.solflare
        walletType = 'solflare'
      }

      if (!provider) {
        showWalletModal()
        return
      }

      try {
        // ç›´æ¥è°ƒç”¨ connect()ï¼Œä¼šå¼¹å‡ºæ‰©å±•è‡ªå¸¦è¿æ¥çª—å£
        const response = await provider.connect()
        walletAddress = response.publicKey.toString()
        walletProvider = provider
        loginType = 'wallet'
        playerName = getAddressShort(walletAddress)
        playerId = walletAddress.slice(0, 16)
        saveWalletToStorage(walletAddress, walletType, playerId)
        if (currentPage === 'lobby') updateLobbyAccount()
      } catch (err) {
        console.error('é’±åŒ…è¿æ¥å¤±è´¥:', err)
        if (err.code !== 4001 && err.code !== -32603) {
          alert(t('connectFailed') + ': ' + (err.message || (lang === 'en' ? 'User cancelled' : 'ç”¨æˆ·å–æ¶ˆ')))
        }
      }
    }

    function saveWalletToStorage(address, type, pid) {
      if (address) {
        var id = pid || address.slice(0, 16)
        localStorage.setItem('walletAddress', address)
        localStorage.setItem('walletType', type || 'phantom')
        localStorage.setItem('playerId', id)
        sessionStorage.setItem('walletAddress', address)
        sessionStorage.setItem('walletType', type || 'phantom')
        sessionStorage.setItem('playerId', id)
      }
    }

    function clearWalletStorage() {
      localStorage.removeItem('walletAddress')
      localStorage.removeItem('walletType')
      localStorage.removeItem('playerId')
      sessionStorage.removeItem('walletAddress')
      sessionStorage.removeItem('walletType')
      sessionStorage.removeItem('playerId')
    }

    function showWalletModal() {
      document.getElementById('wallet-modal').classList.remove('hidden')
    }

    function closeWalletModal() {
      document.getElementById('wallet-modal').classList.add('hidden')
    }

    /** ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹© Phantom æˆ– Solflare æ—¶è°ƒç”¨ï¼ˆå¼¹çª—å†…ç‚¹å‡»ï¼‰ */
    async function connectWallet(walletType) {
      try {
        let provider = null

        if (walletType === 'phantom') {
          if (typeof window.solana !== 'undefined' && window.solana.isPhantom) {
            provider = window.solana
          } else {
            alert(t('noPhantom'))
            closeWalletModal()
            return
          }
        } else if (walletType === 'solflare') {
          if (typeof window.solflare !== 'undefined') {
            provider = window.solflare
          } else {
            alert(t('noSolflare'))
            closeWalletModal()
            return
          }
        }

        if (!provider) {
          closeWalletModal()
          return
        }

        const response = await provider.connect()
        walletAddress = response.publicKey.toString()
        walletProvider = provider
        loginType = 'wallet'
        playerName = getAddressShort(walletAddress)
        playerId = walletAddress.slice(0, 16)
        saveWalletToStorage(walletAddress, walletType, playerId)
        closeWalletModal()
        if (currentPage === 'lobby') updateLobbyAccount()
      } catch (err) {
        console.error('é’±åŒ…è¿æ¥å¤±è´¥:', err)
        alert(t('connectFailed') + ': ' + (err.message || (lang === 'en' ? 'User cancelled' : 'ç”¨æˆ·å–æ¶ˆ')))
        closeWalletModal()
      }
    }

    // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥é’±åŒ…ï¼ˆåˆ·æ–°åæ¢å¤ï¼‰
    async function checkWalletConnection() {
      var savedAddress = localStorage.getItem('walletAddress') || sessionStorage.getItem('walletAddress')
      var savedType = localStorage.getItem('walletType') || sessionStorage.getItem('walletType')
      if (!savedAddress) return
      walletAddress = savedAddress
      loginType = 'wallet'
      playerName = getAddressShort(walletAddress)
      playerId = localStorage.getItem('playerId') || sessionStorage.getItem('playerId') || savedAddress.slice(0, 16)
      try {
        var provider = null
        if ((savedType || 'phantom') === 'phantom' && typeof window.solana !== 'undefined' && window.solana.isPhantom) provider = window.solana
        else if ((savedType || 'solflare') === 'solflare' && typeof window.solflare !== 'undefined') provider = window.solflare
        if (provider && typeof provider.connect === 'function') {
          var opts = (provider.connect.length >= 1) ? { onlyIfTrusted: true } : {}
          await provider.connect(opts).catch(function () {})
          walletProvider = provider
        }
      } catch (e) {}
    }

    function getAddressShort(addr) {
      return addr ? (addr.slice(0, 6) + '...' + addr.slice(-4)) : ''
    }

    function getNicknameForWallet(address) {
      if (!address) return null
      return localStorage.getItem('nickname_' + address)
    }

    function setNicknameForWallet(address, name) {
      if (!address || !name) return
      if (!localStorage.getItem('nickname_' + address)) {
        localStorage.setItem('nickname_' + address, name)
      }
    }

    /** ä»…æ¢å¤å˜é‡ï¼Œä¸åˆ‡æ¢é¡µé¢ */
    function restoreLoginState() {
      if (walletAddress) {
        playerName = getAddressShort(walletAddress)
        playerId = localStorage.getItem('playerId') || sessionStorage.getItem('playerId') || walletAddress.slice(0, 16)
        sessionStorage.setItem('playerName', playerName)
        sessionStorage.setItem('playerId', playerId)
        sessionStorage.setItem('loginType', 'wallet')
        return
      }
      var lastName = localStorage.getItem('lastPlayerName')
      var lastId = localStorage.getItem('lastPlayerId')
      if (lastName && lastId) {
        playerName = lastName
        playerId = lastId
        loginType = localStorage.getItem('lastLoginType') || 'anonymous'
        sessionStorage.setItem('playerName', playerName)
        sessionStorage.setItem('playerId', playerId)
        sessionStorage.setItem('loginType', loginType)
      }
    }

    function updateLobbyAccount() {
      var conn = document.getElementById('lobby-account-connected')
      var btns = document.getElementById('lobby-account-buttons')
      var nameEl = document.getElementById('lobby-account-name')
      if (!conn || !btns) return
      if (playerName) {
        conn.style.display = 'block'
        btns.style.display = 'none'
        if (nameEl) nameEl.textContent = playerName
      } else {
        conn.style.display = 'none'
        btns.style.display = 'flex'
      }
    }

    async function lobbyConnectWallet() {
      await autoConnectWallet()
      if (!walletAddress) return
      playerName = getAddressShort(walletAddress)
      playerId = walletAddress.slice(0, 16)
      sessionStorage.setItem('playerName', playerName)
      sessionStorage.setItem('playerId', playerId)
      localStorage.setItem('lastPlayerName', playerName)
      localStorage.setItem('lastPlayerId', playerId)
      localStorage.setItem('lastLoginType', 'wallet')
      updateLobbyAccount()
    }

    function lobbyAnonymous() {
      playerName = 'Guest_' + Math.random().toString(36).slice(2, 6)
      playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).slice(2, 9)
      loginType = 'anonymous'
      sessionStorage.setItem('playerName', playerName)
      sessionStorage.setItem('playerId', playerId)
      localStorage.setItem('lastPlayerName', playerName)
      localStorage.setItem('lastPlayerId', playerId)
      localStorage.setItem('lastLoginType', loginType)
      updateLobbyAccount()
    }

    function lobbyLogout() {
      walletAddress = ''
      walletProvider = null
      playerName = ''
      playerId = ''
      loginType = 'anonymous'
      clearWalletStorage()
      localStorage.removeItem('lastPlayerName')
      localStorage.removeItem('lastPlayerId')
      localStorage.removeItem('lastLoginType')
      updateLobbyAccount()
    }

    function showGameRules(gameKey) {
      var titleMap = { 'draw-guess': 'drawGuess', 'undercover': 'gameUndercover', 'quiz': 'gameQuiz' }
      var bodyMap = { 'draw-guess': 'drawGuessRules', 'undercover': 'undercoverRules', 'quiz': 'quizRules' }
      var title = document.getElementById('game-rules-title')
      var body = document.getElementById('game-rules-body')
      if (title && body) {
        title.textContent = t(titleMap[gameKey] || 'drawGuess')
        body.textContent = t(bodyMap[gameKey] || 'drawGuessRules')
      }
      document.getElementById('game-rules-modal').classList.remove('hidden')
    }

    function closeGameRulesModal() {
      document.getElementById('game-rules-modal').classList.add('hidden')
    }

    function logoutWallet() {
      walletAddress = ''
      walletProvider = null
      loginType = 'anonymous'
      playerId = sessionStorage.getItem('playerId') || 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
      clearWalletStorage()
      var walletStatus = document.getElementById('wallet-status')
      var btnWallet = document.getElementById('btn-wallet')
      var btnAnonymous = document.getElementById('btn-anonymous')
      if (walletStatus) {
        walletStatus.classList.add('hidden')
        walletStatus.classList.remove('connected')
        walletStatus.innerHTML = ''
      }
      if (btnWallet) btnWallet.style.background = 'var(--surface-hover)'
      if (btnAnonymous) btnAnonymous.style.background = 'var(--primary)'
    }

    // ========== é¡µé¢åˆ‡æ¢ ==========
    function showPage(pageId) {
      document.querySelectorAll('[id^="page-"]').forEach(el => el.classList.add('hidden'))
      document.getElementById(`page-${pageId}`).classList.remove('hidden')
      currentPage = pageId
    }

    // ========== ç™»å½•é¡µ ==========
    async function handleEnter() {
      var nicknameInput = document.getElementById('input-nickname')
      var nickname = (nicknameInput && nicknameInput.value) ? nicknameInput.value.trim() : ''
      if (loginType === 'wallet' && walletAddress) {
        var existing = getNicknameForWallet(walletAddress)
        if (existing) {
          nickname = existing
        } else if (!nickname) {
          alert(t('nicknameWalletOnce'))
          return
        } else {
          setNicknameForWallet(walletAddress, nickname)
        }
      } else if (!nickname) {
        alert(t('nicknameRequired'))
        return
      }

      if (loginType === 'wallet' && !walletAddress) {
        await autoConnectWallet()
        if (!walletAddress) return
        nickname = nicknameInput ? nicknameInput.value.trim() : ''
        if (!nickname) {
          alert(t('nicknameWalletOnce'))
          return
        }
        setNicknameForWallet(walletAddress, nickname)
      }

      playerName = nickname
      if (!playerId) {
        playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
      }

      sessionStorage.setItem('playerName', playerName)
      sessionStorage.setItem('playerId', playerId)
      sessionStorage.setItem('loginType', loginType)
      localStorage.setItem('lastPlayerName', playerName)
      localStorage.setItem('lastPlayerId', playerId)
      localStorage.setItem('lastLoginType', loginType)

      updateOnlineCount()
      showPage('lobby')
      updateLobbySyncTip()
      updateExistingRoomsList()
    }

    async function updateOnlineCount() {
      let total = 0
      if (apiBase) {
        try {
          const r = await fetch(apiBase + '/rooms')
          if (r.ok) {
            const list = await r.json()
            list.forEach((x) => { total += x.playerCount || 0 })
          }
        } catch (e) {}
      }
      if (total === 0) {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i)
          if (key && key.startsWith('room_') && key.endsWith('_players')) {
            const players = JSON.parse(localStorage.getItem(key) || '[]')
            total += players.length
          }
        }
      }
      const el = document.getElementById('online-count')
      if (el) el.textContent = total || 1
    }

    /** è·å–æ‰€æœ‰å·²æœ‰ç©å®¶çš„æˆ¿é—´ï¼ˆç”¨äºå¤§å…ã€Œå¿«é€Ÿè¿›å…¥ã€ï¼‰ */
    async function getExistingRooms() {
      if (apiBase) {
        try {
          const r = await fetch(apiBase + '/rooms')
          if (r.ok) return await r.json()
        } catch (e) {}
      }
      const list = []
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key && key.startsWith('room_') && key.endsWith('_players')) {
          const rid = key.replace('room_', '').replace('_players', '')
          const players = JSON.parse(localStorage.getItem(key) || '[]')
          if (players.length > 0) list.push({ roomId: rid, playerCount: players.length })
        }
      }
      return list.sort((a, b) => b.playerCount - a.playerCount)
    }

    function updateLobbySyncTip() {
      var el = document.getElementById('lobby-sync-tip')
      if (!el) return
      el.style.display = 'none'
    }

    /** åˆ·æ–°å¤§å…ã€Œå·²æœ‰æˆ¿é—´ã€åˆ—è¡¨ */
    async function updateExistingRoomsList() {
      const container = document.getElementById('existing-rooms-list')
      if (!container) return
      const list = await getExistingRooms()
      if (list.length === 0) {
        container.innerHTML = '<p style="color: var(--text-muted); font-size: 0.9rem; margin: 0">' + t('noRooms') + '</p>'
        return
      }
      container.innerHTML = list.map(function (r) {
        return '<div style="display: flex; align-items: center; justify-content: space-between; padding: 0.6rem 0; border-bottom: 1px solid var(--surface-hover)"><span>' + t('roomPeople', { id: r.roomId, n: r.playerCount }) + '</span><button type="button" onclick="quickEnterRoom(\'' + r.roomId + '\')" style="padding: 0.4rem 0.8rem; font-size: 0.85rem">' + t('quickEnter') + '</button></div>'
      }).join('')
    }

    /** ä»å¤§å…å¿«é€Ÿè¿›å…¥æŒ‡å®šæˆ¿é—´ */
    function quickEnterRoom(id) {
      joinRoomById(id)
    }

    // ========== å¤§å…é¡µ ==========
    function enterGame(gameId) {
      if (!playerName) {
        alert(lang === 'en' ? 'Please connect wallet or use Anonymous first.' : 'è¯·å…ˆè¿æ¥é’±åŒ…æˆ–åŒ¿åç™»å½•ã€‚')
        return
      }
      if (gameId === 'draw-guess') {
        roomId = Math.floor(Math.random() * 9000 + 1000).toString()
        joinRoomById(roomId)
      }
    }

    function joinRoom() {
      if (!playerName) {
        alert(lang === 'en' ? 'Please connect wallet or use Anonymous first.' : 'è¯·å…ˆè¿æ¥é’±åŒ…æˆ–åŒ¿åç™»å½•ã€‚')
        return
      }
      const code = prompt(t('promptRoomCode'))
      if (code && /^\d{4}$/.test(code)) {
        joinRoomById(code)
      } else if (code) {
        alert(t('invalidRoomCode'))
      }
    }

    async function joinRoomById(id) {
      roomId = id
      document.getElementById('room-id').textContent = roomId
      document.getElementById('game-room-id').textContent = roomId

      var state = await getRoomStateAsync(roomId)
      if (state && state.status === 'playing') {
        alert(t('gameStartedNoJoin'))
        roomId = ''
        return
      }

      const player = {
        id: playerId,
        name: playerName,
        ready: false,
        score: 0,
        walletAddress: walletAddress || null
      }
      roomPlayers = await addPlayerToRoom(roomId, player)
      if (!roomPlayers) {
        alert(t('gameStartedNoJoin'))
        roomId = ''
        return
      }

      showPage('room')
      updateRoomPage(await getRoomStateAsync(roomId))
      if (roomPollTimer) clearInterval(roomPollTimer)
      if (countdownTimer) clearInterval(countdownTimer)
      roomPollTimer = setInterval(async () => {
        if (currentPage !== 'room' || !roomId) return
        roomPlayers = await getRoomPlayersAsync(roomId)
        if (roomPlayers.every(function (p) { return p.id !== playerId })) {
          if (roomPollTimer) { clearInterval(roomPollTimer); roomPollTimer = null }
          if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null }
          alert(t('timeoutKicked'))
          goToLobby()
          return
        }
        var state = await getRoomStateAsync(roomId)
        updateRoomPage(state)
        if (state && state.status === 'playing') {
          if (roomPollTimer) { clearInterval(roomPollTimer); roomPollTimer = null }
          if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null }
          startGame(state)
          return
        }
        await updateCountdown(state)
      }, 500)
      countdownTimer = setInterval(async function () {
        if (currentPage !== 'room' || !roomId) return
        var state = await getRoomStateAsync(roomId)
        var hasCountdown = await updateCountdown(state)
        roomPlayers = await getRoomPlayersAsync(roomId)
        if (state && state.countdownEndTime && state.confirmedPlayerIds && state.status === 'waiting') {
          var allConfirmed = roomPlayers.length >= 2 && roomPlayers.every(function (p) { return state.confirmedPlayerIds.indexOf(p.id) >= 0 })
          if (allConfirmed) {
            if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null }
            var kept = roomPlayers.slice()
            await setRoomStateAsync(roomId, { countdownEndTime: null, confirmedPlayerIds: [] })
            var painterIndex = Math.floor(Math.random() * kept.length)
            var painterId = kept[painterIndex].id
            var maxR = kept.length * 3
            gameWordSeed = roomId + '-' + Date.now()
            var dailyWords = getDailyWords(gameWordSeed)
            var firstWord = dailyWords[0]
            await setRoomStateAsync(roomId, { status: 'playing', gameWordSeed: gameWordSeed, painterId: painterId, wordIndex: 0, word: firstWord.en, wordCategory: firstWord.cat_zh, wordCategoryEn: firstWord.cat_en, currentRound: 1, maxRounds: maxR })
            startGame({ status: 'playing', gameWordSeed: gameWordSeed, painterId: painterId, wordIndex: 0, word: firstWord.en, wordCategory: firstWord.cat_zh, wordCategoryEn: firstWord.cat_en, currentRound: 1, maxRounds: maxR })
            return
          }
        }
        if (!hasCountdown && state && state.status === 'waiting' && state.countdownEndTime && state.countdownEndTime <= Date.now()) {
          var confirmedIds = state.confirmedPlayerIds || []
          var kept = roomPlayers.filter(function (p) { return confirmedIds.indexOf(p.id) >= 0 })
          await saveRoomPlayersAsync(roomId, kept)
          roomPlayers = kept
          await setRoomStateAsync(roomId, { countdownEndTime: null, confirmedPlayerIds: [] })
          if (kept.length >= 2) {
            var painterIndex = Math.floor(Math.random() * kept.length)
            var painterId = kept[painterIndex].id
            var maxR = kept.length * 3
            gameWordSeed = roomId + '-' + Date.now()
            var dailyWords = getDailyWords(gameWordSeed)
            var firstWord = dailyWords[0]
            await setRoomStateAsync(roomId, { status: 'playing', gameWordSeed: gameWordSeed, painterId: painterId, wordIndex: 0, word: firstWord.en, wordCategory: firstWord.cat_zh, wordCategoryEn: firstWord.cat_en, currentRound: 1, maxRounds: maxR })
            startGame({ status: 'playing', gameWordSeed: gameWordSeed, painterId: painterId, wordIndex: 0, word: firstWord.en, wordCategory: firstWord.cat_zh, wordCategoryEn: firstWord.cat_en, currentRound: 1, maxRounds: maxR })
          } else {
            updateRoomPage(await getRoomStateAsync(roomId))
          }
        }
      }, 500)
    }

    async function goToLobby() {
      if (roomPollTimer) { clearInterval(roomPollTimer); roomPollTimer = null }
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null }
      if (roomId && playerId) {
        await removePlayerFromRoom(roomId, playerId)
      }
      roomId = ''
      updateOnlineCount()
      showPage('lobby')
      updateLobbyAccount()
      updateLobbySyncTip()
      updateExistingRoomsList()
    }

    // ========== æˆ¿é—´é¡µ ==========
    function updateRoomPage(state) {
      const list = document.getElementById('player-list')
      const countEl = document.getElementById('player-count')
      if (!list || !countEl) return
      countEl.textContent = roomPlayers.length
      var inCountdown = state && state.status === 'waiting' && (state.countdownRemaining > 0 || (state.countdownEndTime && (state.countdownEndTime - Date.now()) > 0))
      var confirmedIds = (state && state.confirmedPlayerIds) ? state.confirmedPlayerIds : []

      if (roomPlayers.length === 0) {
        list.innerHTML = '<li style="padding: 1rem; text-align: center; color: var(--text-muted)">' + t('noPlayers') + '</li>'
      } else {
        list.innerHTML = roomPlayers.map(function (p) {
          var right = inCountdown ? (confirmedIds.indexOf(p.id) >= 0 ? 'âœ… ' + t('confirmed') : 'âŒ ' + t('notConfirmed')) : (p.ready ? 'âœ… ' + t('ready') : 'âŒ ' + t('notReady'))
          return '<li style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0; border-bottom: 1px solid var(--surface-hover)"><span>' + p.name + (p.walletAddress ? ' ğŸ’¼' : '') + '</span><span>' + right + '</span></li>'
        }).join('')
      }
    }

    var countdownTimer = null

    async function updateCountdown(state) {
      const countdownEl = document.getElementById('countdown-text')
      const confirmArea = document.getElementById('confirm-area')
      const btnStart = document.getElementById('btn-start')
      const confirmDone = document.getElementById('confirm-done')
      if (!countdownEl) return

      if (state && state.status === 'waiting' && (state.countdownRemaining !== undefined || (state.countdownEndTime && (state.countdownEndTime - Date.now()) > 0))) {
        var remaining = state.countdownRemaining
        if (remaining === undefined && state.countdownEndTime) remaining = Math.max(0, Math.floor((state.countdownEndTime - Date.now()) / 1000))
        if (remaining !== undefined && remaining > 0) {
          countdownEl.style.display = 'block'
          countdownEl.textContent = t('countdownTip', { n: remaining })
          if (confirmArea && btnStart) {
            var confirmed = (state.confirmedPlayerIds || []).indexOf(playerId) >= 0
            confirmArea.style.display = 'block'
            btnStart.style.display = confirmed ? 'none' : 'inline-block'
            if (confirmDone) confirmDone.style.display = confirmed ? 'inline' : 'none'
          }
          return true
        } else {
          countdownEl.style.display = 'none'
          if (confirmArea) confirmArea.style.display = 'none'
          return false
        }
      } else {
        countdownEl.style.display = 'none'
        if (confirmArea) confirmArea.style.display = 'none'
        return false
      }
    }

    async function confirmStart() {
      await confirmStartAsync(roomId, playerId)
      roomPlayers = await getRoomPlayersAsync(roomId)
      var state = await getRoomStateAsync(roomId)
      updateRoomPage(state)
      await updateCountdown(state)
    }

    async function toggleReady() {
      isReady = !isReady
      document.getElementById('btn-ready').textContent = isReady ? t('cancelReady') : t('ready')
      await updatePlayerReady(roomId, playerId, isReady)
      roomPlayers = await getRoomPlayersAsync(roomId)

      var state = await getRoomStateAsync(roomId)
      var now = Date.now()
      if (isReady && (!state.countdownEndTime || state.countdownEndTime < now)) {
        await setRoomStateAsync(roomId, { countdownEndTime: now + 30000, confirmedPlayerIds: [playerId] })
      }
      state = await getRoomStateAsync(roomId)
      updateRoomPage(state)
      await updateCountdown(state)
    }

    function sendChat() {
      const input = document.getElementById('chat-input')
      const text = input.value.trim()
      if (!text) return
      
      const messages = document.getElementById('chat-messages')
      var noMsgZh = 'æš‚æ— æ¶ˆæ¯'
      var noMsgEn = 'No messages'
      if (messages.innerHTML.indexOf(noMsgZh) >= 0 || messages.innerHTML.indexOf(noMsgEn) >= 0) {
        messages.innerHTML = ''
      }
      
      messages.innerHTML += `<div style="margin-bottom: 0.25rem"><strong>${playerName}:</strong> ${text}</div>`
      messages.scrollTop = messages.scrollHeight
      input.value = ''
    }

    var wordCategory = 'åŠ¨ç‰©'
    var WORD_LIST = [
      { en: 'Cat', zh: 'çŒ«', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['cat', 'çŒ«', 'cats'] },
      { en: 'Dog', zh: 'ç‹—', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['dog', 'ç‹—', 'dogs'] },
      { en: 'Bird', zh: 'é¸Ÿ', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['bird', 'é¸Ÿ', 'birds'] },
      { en: 'Fish', zh: 'é±¼', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['fish', 'é±¼'] },
      { en: 'Tree', zh: 'æ ‘', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['tree', 'æ ‘', 'trees'] },
      { en: 'Sun', zh: 'å¤ªé˜³', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['sun', 'å¤ªé˜³'] },
      { en: 'Car', zh: 'æ±½è½¦', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['car', 'æ±½è½¦', 'cars'] },
      { en: 'Book', zh: 'ä¹¦', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['book', 'ä¹¦', 'books'] },
      { en: 'Apple', zh: 'è‹¹æœ', cat_zh: 'é£Ÿç‰©', cat_en: 'Food', answers: ['apple', 'è‹¹æœ', 'apples'] },
      { en: 'House', zh: 'æˆ¿å­', cat_zh: 'å»ºç­‘', cat_en: 'Building', answers: ['house', 'æˆ¿å­', 'home', 'å®¶'] },
      { en: 'Water', zh: 'æ°´', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['water', 'æ°´'] },
      { en: 'Fire', zh: 'ç«', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['fire', 'ç«'] },
      { en: 'Moon', zh: 'æœˆäº®', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['moon', 'æœˆäº®'] },
      { en: 'Star', zh: 'æ˜Ÿæ˜Ÿ', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['star', 'æ˜Ÿæ˜Ÿ', 'stars'] },
      { en: 'Flower', zh: 'èŠ±', cat_zh: 'æ¤ç‰©', cat_en: 'Plant', answers: ['flower', 'èŠ±', 'flowers'] },
      { en: 'Mountain', zh: 'å±±', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['mountain', 'å±±', 'hill', 'å°å±±'] },
      { en: 'Rain', zh: 'é›¨', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['rain', 'é›¨'] },
      { en: 'Snow', zh: 'é›ª', cat_zh: 'è‡ªç„¶', cat_en: 'Nature', answers: ['snow', 'é›ª'] },
      { en: 'Elephant', zh: 'å¤§è±¡', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['elephant', 'å¤§è±¡'] },
      { en: 'Lion', zh: 'ç‹®å­', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['lion', 'ç‹®å­', 'lions'] },
      { en: 'Tiger', zh: 'è€è™', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['tiger', 'è€è™', 'tigers'] },
      { en: 'Rabbit', zh: 'å…”å­', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['rabbit', 'å…”å­', 'rabbits'] },
      { en: 'Butterfly', zh: 'è´è¶', cat_zh: 'åŠ¨ç‰©', cat_en: 'Animal', answers: ['butterfly', 'è´è¶', 'butterflies'] },
      { en: 'Bicycle', zh: 'è‡ªè¡Œè½¦', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['bicycle', 'è‡ªè¡Œè½¦', 'bike', 'å•è½¦'] },
      { en: 'Phone', zh: 'æ‰‹æœº', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['phone', 'æ‰‹æœº', 'telephone', 'ç”µè¯'] },
      { en: 'Computer', zh: 'ç”µè„‘', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['computer', 'ç”µè„‘', 'pc'] },
      { en: 'Airplane', zh: 'é£æœº', cat_zh: 'äº¤é€š', cat_en: 'Transport', answers: ['airplane', 'é£æœº', 'plane'] },
      { en: 'Ship', zh: 'èˆ¹', cat_zh: 'äº¤é€š', cat_en: 'Transport', answers: ['ship', 'èˆ¹', 'boat', 'å°èˆ¹'] },
      { en: 'Bridge', zh: 'æ¡¥', cat_zh: 'å»ºç­‘', cat_en: 'Building', answers: ['bridge', 'æ¡¥'] },
      { en: 'School', zh: 'å­¦æ ¡', cat_zh: 'å»ºç­‘', cat_en: 'Building', answers: ['school', 'å­¦æ ¡'] },
      { en: 'Doctor', zh: 'åŒ»ç”Ÿ', cat_zh: 'èŒä¸š', cat_en: 'Occupation', answers: ['doctor', 'åŒ»ç”Ÿ'] },
      { en: 'Teacher', zh: 'è€å¸ˆ', cat_zh: 'èŒä¸š', cat_en: 'Occupation', answers: ['teacher', 'è€å¸ˆ'] },
      { en: 'Music', zh: 'éŸ³ä¹', cat_zh: 'æŠ½è±¡', cat_en: 'Abstract', answers: ['music', 'éŸ³ä¹'] },
      { en: 'Love', zh: 'çˆ±', cat_zh: 'æŠ½è±¡', cat_en: 'Abstract', answers: ['love', 'çˆ±'] },
      { en: 'Happy', zh: 'å¼€å¿ƒ', cat_zh: 'æƒ…ç»ª', cat_en: 'Emotion', answers: ['happy', 'å¼€å¿ƒ', 'å¿«ä¹'] },
      { en: 'Run', zh: 'è·‘', cat_zh: 'åŠ¨ä½œ', cat_en: 'Action', answers: ['run', 'è·‘', 'running'] },
      { en: 'Eat', zh: 'åƒ', cat_zh: 'åŠ¨ä½œ', cat_en: 'Action', answers: ['eat', 'åƒ', 'eating'] },
      { en: 'Sleep', zh: 'ç¡', cat_zh: 'åŠ¨ä½œ', cat_en: 'Action', answers: ['sleep', 'ç¡', 'sleeping'] },
      { en: 'Ball', zh: 'çƒ', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['ball', 'çƒ', 'balls'] },
      { en: 'Key', zh: 'é’¥åŒ™', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['key', 'é’¥åŒ™', 'keys'] },
      { en: 'Clock', zh: 'é’Ÿ', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['clock', 'é’Ÿ', 'æ—¶é’Ÿ', 'watch', 'è¡¨'] },
      { en: 'Umbrella', zh: 'ä¼', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['umbrella', 'ä¼'] },
      { en: 'Camera', zh: 'ç›¸æœº', cat_zh: 'ç‰©å“', cat_en: 'Object', answers: ['camera', 'ç›¸æœº', 'ç…§ç›¸æœº'] }
    ]

    function seedRandom(seed) {
      var n = 0
      for (var i = 0; i < seed.length; i++) n = (n << 5) - n + seed.charCodeAt(i) | 0
      return function () {
        n = Math.imul(n ^ (n >>> 15), 1 | n)
        return ((n ^ (n >>> 7)) >>> 0) / 4294967296
      }
    }

    function getDailyWords(seed) {
      var s = seed || new Date().toISOString().slice(0, 10)
      var rng = seedRandom(s)
      var list = WORD_LIST.slice()
      for (var i = list.length - 1; i > 0; i--) {
        var j = Math.floor(rng() * (i + 1))
        var t = list[i]; list[i] = list[j]; list[j] = t
      }
      return list
    }

    function getWordByIndex(index) {
      var list = gameWordSeed ? getDailyWords(gameWordSeed) : getDailyWords()
      return list[index % list.length] || list[0]
    }

    function isGuessCorrect(guess, wordObj) {
      if (!wordObj || !wordObj.answers) return false
      var g = (guess || '').trim().toLowerCase()
      if (!g) return false
      return wordObj.answers.some(function (a) { return (a + '').trim().toLowerCase() === g })
    }

    function renderGameChat(guesses) {
      var messages = document.getElementById('game-chat-messages')
      if (!messages) return
      if (!guesses || !guesses.length) {
        messages.innerHTML = ''
        return
      }
      var html = guesses.map(function (g) {
        if (g.correct) {
          if (g.playerId === playerId) return '<div style="color: var(--success); margin-bottom: 0.25rem">' + t('xx') + ' Â· ' + t('youGotIt') + '</div>'
          return '<div style="color: var(--success); margin-bottom: 0.25rem">' + t('xx') + ' Â· ' + escapeHtml(g.playerName || '?') + ' ' + t('someoneGotIt') + '</div>'
        }
        return '<div style="margin-bottom: 0.25rem">' + escapeHtml(g.playerName || '?') + ': ' + escapeHtml(g.content) + '</div>'
      }).join('')
      messages.innerHTML = html
      messages.scrollTop = messages.scrollHeight
    }

    function escapeHtml(s) {
      const div = document.createElement('div')
      div.textContent = s
      return div.innerHTML
    }

    // ========== æ¸¸æˆé¡µ ==========
    function startGame(serverState) {
      if (roomPlayers.length === 0) return

      maxRounds = (serverState && serverState.maxRounds) ? serverState.maxRounds : (roomPlayers.length * 3)
      if (serverState && serverState.gameWordSeed) gameWordSeed = serverState.gameWordSeed
      if (serverState && serverState.status === 'playing' && serverState.painterId) {
        currentRound = serverState.currentRound || 1
        var wordIdx = serverState.wordIndex != null ? serverState.wordIndex : 0
        currentWordObj = getWordByIndex(wordIdx)
        painterWord = currentWordObj.en
        wordCategory = currentWordObj.cat_zh
        roomPlayers.forEach(function (p) { p.isPainter = p.id === serverState.painterId })
      } else {
        var painterIndex = Math.floor(Math.random() * roomPlayers.length)
        roomPlayers.forEach(function (p, i) { p.isPainter = i === painterIndex })
        currentWordObj = getWordByIndex(0)
        painterWord = currentWordObj.en
        wordCategory = currentWordObj.cat_zh
      }

      isPainter = roomPlayers.find(function (p) { return p.id === playerId })?.isPainter || false
      var painter = roomPlayers.find(function (p) { return p.isPainter })

      document.getElementById('painter-name').textContent = painter ? painter.name : '-'
      document.getElementById('max-rounds').textContent = maxRounds
      document.getElementById('max-rounds-info').textContent = maxRounds
      updateRoundSuffix()
      document.getElementById('word-display').textContent = isPainter ? (currentWordObj ? (currentWordObj.en + ' / ' + currentWordObj.zh) : painterWord) : getCategoryDisplayForGuesser()
      document.getElementById('guess-input-area').style.display = isPainter ? 'none' : 'flex'
      document.getElementById('current-round').textContent = currentRound
      document.getElementById('round-info').textContent = currentRound

      var drawPainter = document.getElementById('draw-section-painter')
      var drawGuesser = document.getElementById('draw-section-guesser')
      var toolbar = document.getElementById('draw-toolbar')
      if (drawPainter) drawPainter.style.display = 'block'
      if (drawGuesser) drawGuesser.style.display = 'none'
      if (toolbar) toolbar.style.display = isPainter ? 'flex' : 'none'
      var pageGame = document.getElementById('page-game')
      if (pageGame) pageGame.setAttribute('data-role', isPainter ? 'painter' : 'guesser')

      showPage('game')
      updateGamePage()
      const canvas = document.getElementById('draw-canvas')
      if (canvas) {
        const ctx = canvas.getContext('2d')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }
      initCanvas()
      startRoundTimer()
      if (gamePollTimer) clearInterval(gamePollTimer)
      gamePollTimer = setInterval(async function () {
        if (currentPage !== 'game' && currentPage !== 'round-end') return
        if (!roomId) return
        var state = await getRoomStateAsync(roomId)
        if (state.gameEnded) {
          if (gamePollTimer) { clearInterval(gamePollTimer); gamePollTimer = null }
          getRoomPlayersAsync(roomId).then(function (players) {
            if (players && players.length) roomPlayers = players
            showGameEnd()
          })
          return
        }
        if (state.gameWordSeed) gameWordSeed = state.gameWordSeed
        if (currentPage === 'game') {
          renderGameChat(state.guesses || [])
          var guesses = state.guesses || []
          var correctSet = {}
          guesses.forEach(function (g) { if (g.correct) correctSet[g.playerId] = true })
          var numCorrect = Object.keys(correctSet).length
          var numGuessers = Math.max(0, roomPlayers.length - 1)
          if (!state.roundEnded && numGuessers > 0 && numCorrect >= numGuessers) {
            setTimeout(function () { triggerRoundEnd() }, 300)
          }
          // ç”»å®¶ç»˜åˆ¶æ—¶æˆ–æ­£åœ¨åŒæ­¥æ—¶ï¼Œä¸æ›´æ–°ç”»å¸ƒ
          if ((!isPainter || (!drawing && !isSyncingCanvas)) && !isSyncingCanvas) {
            const canvas = document.getElementById('draw-canvas')
            if (canvas) {
              const ctx = canvas.getContext('2d')
              if (state.canvasData) {
                const currentData = canvas.toDataURL('image/png')
                if (currentData !== state.canvasData) {
                  const img = new Image()
                  img.onload = function () {
                    // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢åœ¨åŠ è½½è¿‡ç¨‹ä¸­å¼€å§‹ç»˜åˆ¶
                    if (drawing && isPainter) return
                    ctx.clearRect(0, 0, canvas.width, canvas.height)
                    ctx.drawImage(img, 0, 0)
                  }
                  img.src = state.canvasData
                }
              } else {
                // å¦‚æœæœåŠ¡å™¨ä¸Šæ²¡æœ‰ç”»å¸ƒæ•°æ®ï¼Œæ¸…ç©ºç”»å¸ƒï¼ˆä½†ç”»å®¶ç»˜åˆ¶æ—¶ä¸æ¸…ç©ºï¼‰
                if (!isPainter || !drawing) {
                  const currentData = canvas.toDataURL('image/png')
                  const emptyCanvas = document.createElement('canvas')
                  emptyCanvas.width = canvas.width
                  emptyCanvas.height = canvas.height
                  const emptyData = emptyCanvas.toDataURL('image/png')
                  if (currentData !== emptyData) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height)
                  }
                }
              }
            }
          }
          if (state.wordIndex != null) {
            currentWordObj = getWordByIndex(state.wordIndex)
            painterWord = currentWordObj.en
            wordCategory = currentWordObj.cat_zh
          }
          if (state.currentRound != null && state.currentRound !== currentRound) {
            currentRound = state.currentRound
            document.getElementById('current-round').textContent = currentRound
            document.getElementById('round-info').textContent = currentRound
            updateRoundSuffix()
          }
          if (state.painterId != null) {
            roomPlayers.forEach(function (p) { p.isPainter = p.id === state.painterId })
            isPainter = roomPlayers.find(function (p) { return p.id === playerId })?.isPainter || false
            var painter = roomPlayers.find(function (p) { return p.isPainter })
            document.getElementById('painter-name').textContent = painter ? painter.name : '-'
            document.getElementById('word-display').textContent = isPainter ? (currentWordObj ? (currentWordObj.en + ' / ' + currentWordObj.zh) : painterWord) : getCategoryDisplayForGuesser()
            document.getElementById('guess-input-area').style.display = isPainter ? 'none' : 'flex'
            var drawPainter = document.getElementById('draw-section-painter')
            var drawGuesser = document.getElementById('draw-section-guesser')
            var toolbar = document.getElementById('draw-toolbar')
            if (drawPainter) drawPainter.style.display = 'block'
            if (drawGuesser) drawGuesser.style.display = 'none'
            if (toolbar) toolbar.style.display = isPainter ? 'flex' : 'none'
            var pageGame = document.getElementById('page-game')
            if (pageGame) pageGame.setAttribute('data-role', isPainter ? 'painter' : 'guesser')
          }
          if (state.roundEnded) {
            getRoomPlayersAsync(roomId).then(function (players) {
              if (players && players.length) roomPlayers = players
              updateGamePage()
              showRoundEndPage(state.roundScores || [])
            })
          }
        }
        if (currentPage === 'round-end') {
          if (state.roundEnded === false && state.currentRound != null && state.currentRound !== currentRound) {
            var wi = state.wordIndex != null ? state.wordIndex : (state.currentRound - 1)
            currentWordObj = getWordByIndex(wi)
            painterWord = currentWordObj.en
            wordCategory = currentWordObj.cat_zh
            currentRound = state.currentRound
            roomPlayers.forEach(function (p) { p.isPainter = p.id === state.painterId })
            isPainter = roomPlayers.find(function (p) { return p.id === playerId })?.isPainter || false
            var painter = roomPlayers.find(function (p) { return p.isPainter })
            document.getElementById('painter-name').textContent = painter ? painter.name : '-'
            document.getElementById('word-display').textContent = isPainter ? (currentWordObj ? (currentWordObj.en + ' / ' + currentWordObj.zh) : painterWord) : getCategoryDisplayForGuesser()
            document.getElementById('guess-input-area').style.display = isPainter ? 'none' : 'flex'
            var drawPainter = document.getElementById('draw-section-painter')
            var drawGuesser = document.getElementById('draw-section-guesser')
            var toolbar = document.getElementById('draw-toolbar')
            if (drawPainter) drawPainter.style.display = 'block'
            if (drawGuesser) drawGuesser.style.display = 'none'
            if (toolbar) toolbar.style.display = isPainter ? 'flex' : 'none'
            var pageGame = document.getElementById('page-game')
            if (pageGame) pageGame.setAttribute('data-role', isPainter ? 'painter' : 'guesser')
            document.getElementById('round-info').textContent = currentRound
            document.getElementById('round-time').textContent = roundTime
            updateRoundSuffix()
            showPage('game')
            const canvas = document.getElementById('draw-canvas')
            if (canvas) {
              const ctx = canvas.getContext('2d')
              ctx.clearRect(0, 0, canvas.width, canvas.height)
            }
            initCanvas()
            startRoundTimer()
          }
        }
      }, 500)
    }

    function applyRoundScores(roundScores) {
      roundScores.forEach(function (entry) {
        var p = roomPlayers.find(function (x) { return x.id === entry.playerId })
        if (p) p.score = (p.score || 0) + (entry.addScore || 0)
      })
      updateGamePage()
    }

    function showRoundEndPage(roundScores) {
      if (roundTimer) clearInterval(roundTimer)
      var answerText = currentWordObj ? (currentWordObj.en + ' / ' + currentWordObj.zh) : painterWord
      document.getElementById('round-answer').textContent = answerText
      document.getElementById('round-scores').innerHTML = roundScores.map(function (e) {
        return '<div style="padding: 0.25rem 0; color: var(--success)">' + (e.playerName || '?') + ' +' + (e.addScore || 0) + '</div>'
      }).join('')
      showPage('round-end')
    }

    function updateGamePage() {
      const sorted = [...roomPlayers].sort((a, b) => b.score - a.score)
      document.getElementById('score-list').innerHTML = sorted.map((p, i) =>
        `<li style="padding: 0.25rem 0">${i + 1}. ${p.name} - ${p.score}</li>`
      ).join('')
    }

    function setTool(t) {
      tool = t
      document.getElementById('tool-brush').classList.toggle('active', t === 'brush')
      document.getElementById('tool-eraser').classList.toggle('active', t === 'eraser')
    }

    function clearCanvas() {
      const canvas = document.getElementById('draw-canvas')
      const ctx = canvas.getContext('2d')
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      syncCanvasToServer()
    }

    var canvasSyncTimer = null
    var isSyncingCanvas = false
    async function syncCanvasToServer(immediate) {
      if (!isPainter || !roomId) return
      const canvas = document.getElementById('draw-canvas')
      if (!canvas) return
      if (canvasSyncTimer) clearTimeout(canvasSyncTimer)
      var syncFunc = async function () {
        isSyncingCanvas = true
        const canvasData = canvas.toDataURL('image/png')
        await setRoomStateAsync(roomId, { canvasData: canvasData })
        setTimeout(function () { isSyncingCanvas = false }, 50)
      }
      if (immediate) {
        syncFunc()
      } else {
        canvasSyncTimer = setTimeout(syncFunc, 100)
      }
    }

    async function loadCanvasFromServer() {
      if (!roomId || (drawing && isPainter) || isSyncingCanvas) return
      const canvas = document.getElementById('draw-canvas')
      if (!canvas) return
      const state = await getRoomStateAsync(roomId)
      const ctx = canvas.getContext('2d')
      if (state.canvasData) {
        const currentData = canvas.toDataURL('image/png')
        if (currentData === state.canvasData) return
        const img = new Image()
        img.onload = function () {
          if ((drawing && isPainter) || isSyncingCanvas) return
          ctx.clearRect(0, 0, canvas.width, canvas.height)
          ctx.drawImage(img, 0, 0)
        }
        img.src = state.canvasData
      } else {
        // å¦‚æœæœåŠ¡å™¨ä¸Šæ²¡æœ‰ç”»å¸ƒæ•°æ®ï¼Œæ¸…ç©ºç”»å¸ƒï¼ˆä½†ç”»å®¶ç»˜åˆ¶æ—¶ä¸æ¸…ç©ºï¼‰
        if (!isPainter || !drawing) {
          ctx.clearRect(0, 0, canvas.width, canvas.height)
        }
      }
    }

    function initCanvas() {
      const canvas = document.getElementById('draw-canvas')
      if (!canvas) return
      const ctx = canvas.getContext('2d')
      
      // æ¸…ç†æ—§çš„äº‹ä»¶ç›‘å¬å™¨
      if (canvasResizeHandler) {
        window.removeEventListener('resize', canvasResizeHandler)
      }
      
      // æ¸…ç†ç”»å¸ƒäº‹ä»¶ç›‘å¬å™¨
      canvas.onmousedown = null
      canvas.onmousemove = null
      canvas.onmouseup = null
      canvas.onmouseleave = null
      canvas.ontouchstart = null
      canvas.ontouchmove = null
      canvas.ontouchend = null
      canvas.style.pointerEvents = 'auto'
      
      // å“åº”å¼ç”»å¸ƒï¼ˆæ‰€æœ‰ç©å®¶éƒ½éœ€è¦ï¼‰
      function resizeCanvas() {
        const wrap = canvas.parentElement
        const maxWidth = wrap.clientWidth - 32
        const maxHeight = Math.min(600, window.innerHeight * 0.5)
        const ratio = Math.min(maxWidth / 800, maxHeight / 600)
        canvas.style.width = (800 * ratio) + 'px'
        canvas.style.height = (600 * ratio) + 'px'
      }
      resizeCanvas()
      canvasResizeHandler = resizeCanvas
      window.addEventListener('resize', canvasResizeHandler)

      const getPos = (e) => {
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        if (e.touches) {
          return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY }
        }
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY }
      }

      // åªæœ‰ç”»å®¶æ‰èƒ½ç»˜åˆ¶
      if (isPainter) {
        canvas.onmousedown = canvas.ontouchstart = (e) => {
          e.preventDefault()
          drawing = true
          const pos = getPos(e)
          lastX = pos.x
          lastY = pos.y
        }

        var lastSyncTime = 0
        canvas.onmousemove = canvas.ontouchmove = (e) => {
          if (!drawing) return
          e.preventDefault()
          const pos = getPos(e)
          ctx.strokeStyle = tool === 'eraser' ? '#1e1e2e' : brushColor
          ctx.lineWidth = tool === 'eraser' ? brushSize * 3 : brushSize
          ctx.lineCap = 'round'
          ctx.beginPath()
          ctx.moveTo(lastX, lastY)
          ctx.lineTo(pos.x, pos.y)
          ctx.stroke()
          lastX = pos.x
          lastY = pos.y
          // æ¯300msåŒæ­¥ä¸€æ¬¡ï¼Œé¿å…å¤ªé¢‘ç¹
          var now = Date.now()
          if (now - lastSyncTime > 300) {
            lastSyncTime = now
            syncCanvasToServer()
          }
        }

        canvas.onmouseup = canvas.onmouseleave = canvas.ontouchend = () => {
          if (drawing) {
            drawing = false
            // ç»˜åˆ¶å®Œæˆåç«‹å³åŒæ­¥ï¼Œä¸å»¶è¿Ÿ
            if (canvasSyncTimer) clearTimeout(canvasSyncTimer)
            syncCanvasToServer(true)
          }
        }

        var brushColorEl = document.getElementById('brush-color')
        var brushSizeEl = document.getElementById('brush-size')
        if (brushColorEl) brushColorEl.onchange = (e) => { brushColor = e.target.value }
        if (brushSizeEl) brushSizeEl.oninput = (e) => { brushSize = parseInt(e.target.value) }
      } else {
        // çŒœè¯æ–¹ï¼šç¦ç”¨ç»˜åˆ¶ï¼Œä½†å¯ä»¥æŸ¥çœ‹ç”»å¸ƒ
        canvas.style.pointerEvents = 'none'
      }
      
      // åŠ è½½æœåŠ¡å™¨ä¸Šçš„ç”»å¸ƒæ•°æ®ï¼ˆæ‰€æœ‰ç©å®¶éƒ½éœ€è¦ï¼‰
      loadCanvasFromServer()
    }

    async function handleGuess() {
      var input = document.getElementById('guess-input')
      var raw = input.value.trim()
      var guess = raw.toUpperCase()
      if (!guess) return
      input.value = ''
      var correct = currentWordObj ? isGuessCorrect(guess, currentWordObj) : (guess === painterWord)
      await postGuessAsync(roomId, {
        playerId: playerId,
        playerName: playerName,
        content: guess,
        correct: correct,
        timestamp: Date.now()
      })
      var state = await getRoomStateAsync(roomId)
      renderGameChat(state.guesses || [])
      // è‹¥å…¨éƒ¨çŒœå¯¹åˆ™ç»“æŸæœ¬è½®
      var guesses = state.guesses || []
      var correctSet = {}
      guesses.forEach(function (g) {
        if (g.correct) correctSet[g.playerId] = true
      })
      var numCorrect = Object.keys(correctSet).length
      var numGuessers = Math.max(0, roomPlayers.length - 1)
      if (numGuessers > 0 && numCorrect >= numGuessers) {
        setTimeout(function () { triggerRoundEnd() }, 500)
      }
    }

    function startRoundTimer() {
      if (roundTimer) clearInterval(roundTimer)
      roundTime = 45
      roundTimer = setInterval(function () {
        roundTime--
        document.getElementById('round-time').textContent = roundTime
        if (roundTime <= 0) {
          clearInterval(roundTimer)
          triggerRoundEnd()
        }
      }, 1000)
    }

    var SCORE_BY_ORDER = [100, 80, 60, 50, 40]
    // ç”»å®¶æ ¹æ®çŒœå¯¹äººæ•°å¾—åˆ†ï¼š0äºº=0, 1äºº=40, 2äºº=70, 3äºº=100, 4äºº+=120
    var PAINTER_SCORE_BY_COUNT = [0, 40, 70, 100, 120]

    async function triggerRoundEnd() {
      if (roundTimer) clearInterval(roundTimer)
      var state = await getRoomStateAsync(roomId)
      if (state.roundEnded && state.roundScores) {
        var players = await getRoomPlayersAsync(roomId)
        if (players && players.length) roomPlayers = players
        updateGamePage()
        showRoundEndPage(state.roundScores)
        return
      }
      var guesses = state.guesses || []
      var allCorrect = guesses.filter(function (g) { return g.correct }).sort(function (a, b) { return a.timestamp - b.timestamp })
      var seen = {}
      var correctList = allCorrect.filter(function (g) {
        if (seen[g.playerId]) return false
        seen[g.playerId] = true
        return true
      })
      var painterIdThisRound = state.painterId
      var roundScores = []
      correctList.forEach(function (g, i) {
        var addScore = SCORE_BY_ORDER[i] != null ? SCORE_BY_ORDER[i] : 40
        roundScores.push({ playerId: g.playerId, playerName: g.playerName, addScore: addScore })
      })
      var numCorrect = correctList.length
      var painterScore = (PAINTER_SCORE_BY_COUNT[Math.min(numCorrect, PAINTER_SCORE_BY_COUNT.length - 1)] ?? PAINTER_SCORE_BY_COUNT[PAINTER_SCORE_BY_COUNT.length - 1])
      if (painterIdThisRound && numCorrect > 0 && painterScore > 0) {
        var painter = roomPlayers.find(function (p) { return p.id === painterIdThisRound })
        roundScores.push({ playerId: painterIdThisRound, playerName: painter ? painter.name : 'ç”»å®¶', addScore: painterScore })
      }
      applyRoundScores(roundScores)
      await saveRoomPlayersAsync(roomId, roomPlayers)
      await setRoomStateAsync(roomId, { roundEnded: true, roundScores: roundScores })
      showRoundEndPage(roundScores)
      setTimeout(function () { advanceRound() }, 3000)
    }

    async function advanceRound() {
      roundTime = 45
      currentRound++
      if (currentRound > maxRounds) {
        if (gamePollTimer) { clearInterval(gamePollTimer); gamePollTimer = null }
        await setRoomStateAsync(roomId, { gameEnded: true, roundEnded: false })
        showGameEnd()
        return
      }
      var nextWordIndex = (currentRound - 1)
      var nextWordObj = getWordByIndex(nextWordIndex)
      var nextCategory = nextWordObj.cat_zh
      var nextCategoryEn = nextWordObj.cat_en
      var currentPainterIndex = roomPlayers.findIndex(function (p) { return p.id === (roomPlayers.find(function (x) { return x.isPainter }) || {}).id })
      var nextPainterIndex = (currentPainterIndex + 1) % roomPlayers.length
      var nextPainterId = roomPlayers[nextPainterIndex].id
      roomPlayers.forEach(function (p, i) { p.isPainter = i === nextPainterIndex })
      isPainter = roomPlayers.find(function (p) { return p.id === playerId })?.isPainter || false
      currentWordObj = nextWordObj
      painterWord = nextWordObj.en
      wordCategory = nextCategory
      await setRoomStateAsync(roomId, {
        roundEnded: false,
        currentRound: currentRound,
        wordIndex: nextWordIndex,
        word: nextWordObj.en,
        wordCategory: nextCategory,
        wordCategoryEn: nextCategoryEn,
        painterId: nextPainterId,
        canvasData: null
      })
      document.getElementById('current-round').textContent = currentRound
      document.getElementById('round-info').textContent = currentRound
      updateRoundSuffix()
      document.getElementById('round-time').textContent = roundTime
      var painter = roomPlayers.find(function (p) { return p.isPainter })
      document.getElementById('painter-name').textContent = painter ? painter.name : '-'
      document.getElementById('word-display').textContent = isPainter ? (currentWordObj ? (currentWordObj.en + ' / ' + currentWordObj.zh) : painterWord) : getCategoryDisplayForGuesser()
      document.getElementById('guess-input-area').style.display = isPainter ? 'none' : 'flex'
      var drawPainter = document.getElementById('draw-section-painter')
      var drawGuesser = document.getElementById('draw-section-guesser')
      var toolbar = document.getElementById('draw-toolbar')
      if (drawPainter) drawPainter.style.display = 'block'
      if (drawGuesser) drawGuesser.style.display = 'none'
      if (toolbar) toolbar.style.display = isPainter ? 'flex' : 'none'
      var pageGame = document.getElementById('page-game')
      if (pageGame) pageGame.setAttribute('data-role', isPainter ? 'painter' : 'guesser')
      showPage('game')
      const canvas = document.getElementById('draw-canvas')
      if (canvas) {
        const ctx = canvas.getContext('2d')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }
      initCanvas()
      startRoundTimer()
    }

    function showGameEnd() {
      var ranking = [...roomPlayers].sort(function (a, b) { return b.score - a.score })
      var scoreUnit = lang === 'en' ? ' pts' : ' åˆ†'
      document.getElementById('final-ranking').innerHTML = ranking.map(function (p, i) {
        var medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : 'ğŸ¥‰'
        return '<li style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: ' + (i === 0 ? 'rgba(124, 58, 237, 0.2)' : 'var(--bg)') + '; border-radius: var(--radius); margin-bottom: 0.5rem"><span>' + medal + ' ' + t('rank', { n: i + 1 }) + ' ' + p.name + '</span><span style="font-weight: 600">' + p.score + scoreUnit + '</span></li>'
      }).join('')
      showPage('game-end')
    }

    function playAgain() {
      roomId = Math.floor(Math.random() * 9000 + 1000).toString()
      document.getElementById('room-id').textContent = roomId
      document.getElementById('game-room-id').textContent = roomId
      roundTime = 45
      currentRound = 1
      isReady = false
      
      const player = {
        id: playerId,
        name: playerName,
        ready: false,
        score: 0,
        walletAddress: walletAddress || null
      }
      roomPlayers = addPlayerToRoom(roomId, player)
      
      showPage('room')
      updateRoomPage()
    }

    // ========== åˆå§‹åŒ– ==========
    async function initApp() {
      applyI18n()
      await checkWalletConnection()
      restoreLoginState()
      showPage('lobby')
      updateLobbyAccount()
      updateLobbySyncTip()
      updateExistingRoomsList()
      updateOnlineCount()
    }
    initApp()
    
    // å®šæœŸæ›´æ–°åœ¨çº¿äººæ•°
    setInterval(updateOnlineCount, 5000)
  </script>
</body>
</html>
